# 第五周笔记

# 隔离

- 服务隔离
    - 动静隔离： CDN，客户端
    - 读写隔离：主
- 轻重隔离
    - 核心隔离：如上面讲到将核心业务独立部署，非核心业务共享资源
    - 热点隔离：local cache
    - 用户隔离：不同的用户可能有不同的级别，例如上面讲到的外部用户和管理员
- 物理隔离
    - 线程
    - 进程
    - 机房
    - 集群

# 超时控制

- fail fast

# 过载保护

- 令牌桶算法
是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。
- 漏桶算法
作为计量工具（The Leaky Bucket Algorithm as a Meter）时，可以用于流量整形（Traffic Shaping）和流量控制（TrafficPolicing）

# 限流

- 计算吞吐量：利特尔法则 L = λ * W
- 熔断
- 客户端限流

# 降级

- 降级本质为: 提供有损服务。
    - UI 模块化，非核心模块降级。
    - BFF 层聚合 API，模块降级。
    - 页面上一次缓存副本。
    - 默认值、热门推荐等。
    - 流量拦截 + 定期数据缓存(过期副本策略)。
    - 处理策略
    页面降级、延迟服务、写/读降级、缓存降级
    抛异常、返回约定协议、Mock 数据、Fallback 处理

# 重试

- 限制重试次数和基于重试分布的策略（重试比率: 10%）。
- 随机化、指数型递增的重试周期: exponential ackoff + jitter。
- client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。
- 只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。

# 负载均衡

- 选择 backend：CPU，client：health、inflight、latency 作为指标，使用一个简单的线性方程进行打分。
- 对新启动的节点使用常量惩罚值（penalty），以及使用探针方式最小化放量，进行预热。
- 打分比较低的节点，避免进入“永久黑名单”而无法恢复，使用统计衰减的方式，让节点指标逐渐恢复到初始状态(即默认值)。
- 当前发出去的请求超过了 predict lagtency，就会加惩罚。
- 指标计算结合 moving average，使用时间衰减，计算vt = v(t-1) * β + at * (1-β) ，β 为若干次幂的倒数即: Math.Exp((-span) / 600ms)

# 最佳实践

- 变更管理:
70％的问题是由变更引起的，恢复可用代码并不总是坏事。
- 避免过载:
过载保护、流量调度等。
- 依赖管理:
任何依赖都可能故障，做 chaos monkey testing，注入故障测试。
- 优雅降级:
有损服务，避免核心链路依赖故障。
- 重试退避:
退让算法，冻结时间，API retry detail 控制策略。
- 超时控制:
进程内 + 服务间 超时控制。
极限压测 + 故障演练。
扩容 + 重启 + 消除有害流量。